<!DOCTYPE html><html><head><title>vc | Iluminación global</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><meta name="robots" content="index,follow"><meta name="theme-color" content="#212121"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://fonts.googleapis.com/css?family=Hind:400,700&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:300,400&amp;display=swap" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons%7CMaterial+Icons+Outlined&amp;display=swap" rel="stylesheet"><style>
      body, input, button {
        font-family: 'Hind', sans-serif;
      }

      code, .hljs {
        font-family: 'Source Code Pro', 'Courier New', Courier, monospace;
      }

      .icon-font {
        font-family: 'Material Icons';
        font-weight: normal;
        font-style: normal;
        font-size: 24px;  /* Preferred icon size */
        display: inline-block;
        line-height: 1;
        text-transform: none;
        letter-spacing: normal;
        word-wrap: normal;
        white-space: nowrap;
        direction: ltr;
      
        /* Support for all WebKit browsers. */
        -webkit-font-smoothing: antialiased;
        /* Support for Safari and Chrome. */
        text-rendering: optimizeLegibility;
      
        /* Support for Firefox. */
        -moz-osx-font-smoothing: grayscale;
      
        /* Support for IE. */
        font-feature-settings: 'liga';
      }

      .icon-font.outline {
        font-family: 'Material Icons Outlined';
      }
    </style><link href="/vc/docs/assets/codedoc-styles.css" rel="stylesheet"><script async="" defer="" src="/vc/docs/assets/codedoc-bundle.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"></head><body><div class="header-0-0-11"><script async="" defer="" src="https://buttons.github.io/buttons.js"></script><a class="github-button" data-color-scheme="no-preference: light; light: light; dark: dark;" data-icon="octicon-star" data-show-count="false" data-size="large" href="https://github.com/CompuVisual2021/vc/">Star</a><br><br><a class="watermark-0-0-10" href="https://github.com/CONNECT-platform/codedoc" target="_blank">Created With<svg viewBox="0 0 536 296" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="codedoc" transform="translate(-244.000000, -364.000000)" fill-rule="nonzero"><path d="M580,532 C615.346224,532 644,560.653776 644,596 C644,631.346224 615.346224,660 580,660 C544.653776,660 516,631.346224 516,596 C516,560.653776 544.653776,532 580,532 Z M716,532 C751.346224,532 780,560.653776 780,596 C780,631.346224 751.346224,660 716,660 L692,660 C687.581722,660 684,656.418278 684,652 C684,647.581722 687.581722,644 692,644 L716,644 C742.509668,644 764,622.509668 764,596 C764,569.490332 742.509668,548 716,548 L692,548 C687.581722,548 684,544.418278 684,540 C684,535.581722 687.581722,532 692,532 L716,532 Z M468,532 C472.418278,532 476,535.581722 476,540 L476,652 C476,656.418278 472.418278,660 468,660 L444,660 C408.653776,660 380,631.346224 380,596 C380,560.653776 408.653776,532 444,532 L468,532 Z M332,532 C336.418278,532 340,535.581722 340,540 L340,652 C340,656.418278 336.418278,660 332,660 L252,660 C247.581722,660 244,656.418278 244,652 L244,540 C244,535.581722 247.581722,532 252,532 L332,532 Z M580,548 C553.490332,548 532,569.490332 532,596 C532,622.509668 553.490332,644 580,644 C606.509668,644 628,622.509668 628,596 C628,569.490332 606.509668,548 580,548 Z M461,548 L444,548 C417.490332,548 396,569.490332 396,596 C396,622.509668 417.490332,644 444,644 L461,644 L461,548 Z M444,364 C479.346224,364 508,392.653776 508,428 C508,463.346224 479.346224,492 444,492 C408.653776,492 380,463.346224 380,428 C380,392.653776 408.653776,364 444,364 Z M332,364 C336.418278,364 340,367.581722 340,372 C340,376.418278 336.418278,380 332,380 L308,380 C281.490332,380 260,401.490332 260,428 C260,454.509668 281.490332,476 308,476 L332,476 C336.418278,476 340,479.581722 340,484 C340,488.418278 336.418278,492 332,492 L308,492 C272.653776,492 244,463.346224 244,428 C244,392.653776 272.653776,364 308,364 L332,364 Z M580,364 C615.346224,364 644,392.653776 644,428 C644,463.346224 615.346224,492 580,492 L556,492 C551.581722,492 548,488.418278 548,484 L548,372 C548,367.581722 551.581722,364 556,364 L580,364 Z M772,364 C776.418278,364 780,367.581722 780,372 C780,376.418278 776.418278,380 772,380 L700,380 L700,420 L772,420 C776.418278,420 780,423.581722 780,428 C780,432.418278 776.418278,436 772,436 L700,436 L700,476 L772,476 C776.418278,476 780,479.581722 780,484 C780,488.418278 776.418278,492 772,492 L692,492 C687.581722,492 684,488.418278 684,484 L684,372 C684,367.581722 687.581722,364 692,364 L772,364 Z M444,380 C417.490332,380 396,401.490332 396,428 C396,454.509668 417.490332,476 444,476 C470.509668,476 492,454.509668 492,428 C492,401.490332 470.509668,380 444,380 Z M580,380 L563,380 L563,476 L580,476 C606.509668,476 628,454.509668 628,428 C628,401.490332 606.509668,380 580,380 Z"></path></g></svg></a></div><div id="-codedoc-container" class="container"><h1 id="iluminación-global" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Iluminación global</h1><h2 id="¿qué-es-la-iluminación-global-de-todos-modos" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>¿Qué es la iluminación global de todos modos?</h2><p>La iluminación global es muy sencilla de simular pero al mismo tiempo es muy costosa por esto el problema está en hacerlo de una manera eficiente que consuma la menor cantidad de recursos posibles.
Primero definamos que es la iluminación global para esto tenemos que saber cómo somos capaces de observar las cosas, este proceso es posible gracias a que percibimos la luz que rebota en los objetos, este rebote puede ser de dos formas:
directa: cuando el objeto rebota directamente la luz de la fuente.</p><p>O indirecta: cuando la luz rebota antes en otros objetos y luego en el que vemos, esto hace que aunque no le llegue luz directamente de la fuente no se vea totalmente oscuro.</p><marker><p align="center">
  <img width="750" height="300" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-globalillum3.png?">
</p>

</marker><p>La iluminación global entonces consiste en simular correctamente ambos tipos de iluminación, esto es muy importante para el renderizado realista de una imagen por esto se podría     pensar que un sistema de iluminación global es imprescindible en una herramienta de renderizado sin embargo al ser tan costosa casi no se ve en los renderizados a tiempo real.
Es muy complicado encontrar un solución genérica debido a que los rayos de luz pueden interactuar de diversas maneras con diversos materiales antes de ser captados por el ojo, un ejemplo sería que el rayo se refleje en una superficie difusa, luego en un vaso de agua (lo cual lo refracta y le da un ligero cambio de dirección), luego golpee una superficie metálica y finalmente llegue al ojo. Cómo estas hay una infinidad de combinaciones posibles. El camino desde la fuente hasta el ojo se denomina camino de luz, desde un punto de vista matemático sabes cómo se comporta este camino de luz gracias a leyes cómo la reflexión y la refracción entre otras, por lo tanto simular estas trayectorias es algo posible para una computadora, entonces nos encontramos con que el rastreo hacia adelante es muy ineficiente, simular desde la fuente hacia el ojo, actualmente se prefiere el rastreo hacia atrás que es muy eficaz para simular la iluminación directa en cualquier caso pero no siempre para una iluminación indirecta.</p><marker><img style="float: left;" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-globalillum1.png?" width="350" height="300">

</marker><marker><p align="left">
  <img width="350" height="300" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-globalillum1a.png?">
</p>

</marker><p>La iluminación directa consiste principalmente en proyectar rayos de sombra desde el punto de sombreado hasta las diversas fuentes de luz,la rapidez de este cálculo depende directamente de la cantidad de fuentes de luz, la iluminación indirecta siempre es más lenta debido a que se requiere simular la trayectoria de muchos rayos de luz que adicionalmente rebotan múltiples veces. Estas simulaciones se pueden hacer por rayos o por trazado de rayos, cómo se ha dicho antes el trazado es bastante costoso y a lo largo de este artículo se comprenderá por qué simular la iluminación global es un proceso costoso.
Lo más importante a recordar es que un objeto puede recibir luz de dos formas, directamente de la fuente de luz o indirectamente de otros objetos, los objetos también pueden verse cómo fuentes de luz debido a que la reflejan y esto se debe tener en cuenta para calcular la cantidad de luz que recibe un punto de sombreado. Cómo se puede ver esto es un problema muy complejo debido a que un objeto A puede iluminar a un objeto B y viceversa en varios ciclos haciendo que la iluminación de cada uno dependa del otro, este proceso implica un intercambio de energía entre superficies que puede dar para siempre. Es posible modelar esto matemáticamente pero resolver las ecuaciones resultantes es muy difícil.
Para simular la iluminación indirecta se simulan los caminos que toman los rayos de luz desde que son emitidos por la fuente hasta que los capta el ojo por esto vamos a hablar de transporte de luz, esto se refiere a la propagación en el espacio a medida que rebota de una superficie a otra. Un algoritmo de transporte de luz es aquel que describe cómo se puede resolver este problema. Cómo se explicará más adelante, simular el transporte de luz y encontrar un algoritmo que lo describa es algo complejo y difícil.</p><h2 id="¿cómo-simulamos-la-iluminación-indirecta-con-el-rastreo-hacia-atrás" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>¿Cómo simulamos la iluminación indirecta con el rastreo hacia atrás?</h2><p>Para comprender la simulación de rastreo hacia atrás primero debemos comprender la simulación de iluminación indirecta esto se puede hacer de una forma formal y matemática sin embargo lo veremos de una manera más sencilla, a través de procesos sencillos. 
Sabemos que la iluminación de un punto P de un objeto proviene de todas las direcciones posibles contenidas dentro de un hemisferio orientado alrededor de la superficie normal N en P. Cuando se trata de iluminación directa es muy sencillo de calcular solo necesitamos recorrer todas las fuentes de luz contenidas en la escena y considerar su dirección, cuando se trata de iluminación indirecta hay que tener en cuenta todas las superficies por encima de P que están reflejando luz hacia P,¿cómo elegimos la posición inicial? no existe una posición de luz puntual única a partir de la cual se pueda calcular la dirección de la luz. De hecho, dado que tratamos con una superficie, hay una infinidad de puntos que podríamos elegir en la superficie de ese objeto para calcular la dirección de la luz.¿Y por qué deberíamos elegir una dirección en lugar de otra teniendo en cuenta que es probable que cada punto de la superficie de ese objeto refleja la luz hacia P?
La respuesta a esta pregunta puede ser sencilla o compleja, hay casos donde este problema se puede resolver de forma analitica generando una ecuacion, este caso se da cuando los objetos que componen la escena son simples (esferas, cuadrículas, rectángulos), cuando los objetos no se ensombrecen entre sí y cuando tienen una iluminación constante en toda su superficie. Esto es un ejemplo bastante específico una vez se agreguen elementos que cambien esta situación se pierde la posible solución analitica y cerrada.</p><p>Por lo tanto, necesitamos encontrar una solución más robusta a este problema en la que la solución funciona independientemente de las formas de los objetos y no depende de la visibilidad de los objetos. Resulta que resolver este problema con estas limitaciones es bastante difícil. Con suerte, podemos usar un método simple llamado integración de Monte Carlo. Pero, ¿por qué la integración ? Porque, en esencia, lo que estamos tratando de hacer es "reunir" toda la luz proveniente de todas las direcciones posibles por encima del hemisferio orientado sobre la normal en P y esto en matemáticas, se puede hacer usando lo que llamamos un operador "integral":</p><p><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">gather light =\int_{Ω}{L_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1608200000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.12251099999999993em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>Ω (la letra griega mayúscula para omega) aquí representa el hemisferio de direcciones orientadas sobre la normal en P. Define la región del espacio sobre la que se realiza la integral.</p><marker><p align="center">
  <img width="300" height="420" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-lightfunction.png?">
</p>

</marker><p>Lo que integramos es generalmente una función. Entonces, ¿cuál es esa función en nuestro caso? Si observa la figura, puede ver la iluminación de P por otros objetos de la escena, en función. Esta función no es cero en las partes del medio disco sobre las que se proyectan los objetos de la escena (suponiendo que los objetos en sí no sean negros). Esta función se puede parametrizar de diferentes formas. Puede ser una función de un ángulo sólido (la letra griega omega:ω) o una función de las coordenadas esféricas θ y ϕ(las letras griegas theta y phi). Estas son solo dos formas diferentes (pero igualmente válidas) de parametrizar el hemisferio. Si solo consideramos el caso 2D de la figura , entonces esto puede definirse simplemente como función del ánguloθ.</p><p>Debería comenzar a ver cómo resolveremos el "qué punto de la superficie de un objeto deberíamos elegir para calcular la contribución de ese objeto a la iluminación de mi punto sombreado P". El hecho de que usemos una integral aquí y necesitamos reunir toda la luz proveniente de todas las direcciones, sugiere que no es un punto en la superficie de ese objeto lo que necesitamos, sino todos los puntos que componen la superficie de esos objetos. Por supuesto, tratar de cubrir la superficie de un objeto con puntos no es práctico ni posible. Los puntos son singularidades, es decir, no tienen área, por lo que no podemos representar una superficie con una infinidad de puntos que no tienen tamaño físico. Para resolver el problema, una posible solución sería dividir la superficie del objeto en una gran cantidad de parches muy pequeños y calcular cuánto contribuye cada parche que hace la superficie de ese objeto a la iluminación de P. Esto, en los gráficos por computadora, es técnicamente posible y se denomina método de radiosidad. Existe un método para resolver el problema de la transferencia de luz entre pequeños parches y P pero tienen limitaciones (son buenas para superficies difusas pero no buenas para superficies brillantes o especulares). Otro método consistiría en dividir la superficie de los objetos en pequeños parches y simular la contribución de estos parches a la iluminación de P reemplazandolos con fuentes de luz puntuales pequeñas. Esto de alguna manera sería posible y una técnica de renderizado avanzada llamada VPL se basa en este principio exacto, pero al final el trazado de rayos de Monte-Carlo es simplemente más simple y más genérico.</p><h3 id="monte-carlo" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Monte Carlo</h3><p>Monte Carlo es otra forma de resolver el problema. Es esencialmente un método estadístico que se basa en la idea de que puede aproximarse o estimar cuánta luz se dirige hacia P por otros objetos en la escena, proyectando rayos desde P en direcciones aleatorias sobre la superficie y evaluando el color de los objetos que estos rayos se cruzan (si cruzan la geometría). Luego se suma la contribución de cada uno de estos rayos y la suma resultante se divide por el número total de rayos. En términos pseudo matemáticos, podemos escribir:</p><p><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>≈</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mstyle scriptlevel="0" displaystyle="false"><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mtext>&nbsp;</mtext><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>R</mi><mi>a</mi><mi>y</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mi>D</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>n</mi><mi>A</mi><mi>b</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>P</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">Gatherlight \thickapprox\frac 1 N\textstyle\sum_{n=0}^N\ castRay(P,randomDirectonAboveP)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326231em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">A</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></span></p><p>Esta es una nota rápida para los lectores que ya están familiarizados con el concepto de integración de Monte Carlo. Probablemente ya sepa que la ecuación completa para calcular una aproximación de una integral usando la integración de Monte Carlo es:</p><p><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⟨</mo><msup><mi>F</mi><mi>N</mi></msup><mo stretchy="false">⟩</mo><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mstyle scriptlevel="0" displaystyle="false"><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>p</mi><mi>d</mi><mi>f</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\langle{F^{N}}\rangle =\frac 1 N\textstyle\sum_{n=0}^{N-1}\frac {f(X_i)} {pd f(X_i)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span><span class="mclose">⟩</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07847em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07847em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>Si no está familiarizado con los métodos de Monte Carlo, puede encontrarlos explicados en dos lecciones de la sección Matemáticas de los gráficos por computadora . Si observa la ecuación anterior, notará un término PDF que ignoraremos por ahora, solo por simplicidad. Solo queremos que comprenda el principio de la integración de Monte Carlo en este punto.
En CG, llamamos a estas muestras de direcciones aleatorias . Lo que realmente hacemos con el muestreo de Monte Carlo es muestrear o tomar muestras sobre el dominio de la integral o la región del espacio sobre la cual la integral <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\int_{Ω}{L_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1608200000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.12251099999999993em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span> se realiza, que en este caso particular es el hemisferio.</p><p>Ahora, no se preocupe todavía por cómo elegimos estas direcciones aleatorias sobre el hemisferio y cuántas muestras N necesitamos usar. Proporcionaremos más información sobre esto pronto. Por ahora, lo que debe recordar de esta parte de la lección es que el método de integración de Monte Carlo sólo le proporciona una estimación (o aproximación) de la solución real que es el resultado de la integral  <span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi mathvariant="normal">Ω</mi></msub><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\int_{Ω}{L_{i}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1608200000000002em;vertical-align:-0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right:0.19445em;position:relative;top:-0.0005599999999999772em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.12251099999999993em;"><span style="top:-2.34418em;margin-left:-0.19445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35582em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span>. La "calidad" de esta aproximación depende principalmente de N, el número de muestras utilizadas. Cuanto mayor sea N, es más probable que obtenga un resultado cercano al resultado real de esta integral. Volveremos sobre este tema en el próximo capítulo.</p><h2 id="¿qué-entendemos-por-muestreo" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>¿Qué entendemos por muestreo?</h2><p>Dado que debemos tener en cuenta el hecho de que la luz puede provenir de cualquier lugar arriba de P, lo que hacemos en cambio en el caso de la integración de Monte Carlo, es seleccionar algunas direcciones aleatorias dentro del hemisferio orientadas sobre P y trazar rayos en estas direcciones en la escena. Si estos rayos se cruzan con alguna geometría en la escena, luego calculamos el color del objeto en el punto de intersección que suponemos que es la cantidad de luz que el objeto intersectado refleja hacia P a lo largo de la dirección definida por el rayo:</p><p>La iluminación global se encuentra punto a punto. Para encontrar la cantidad de luz que llega a un punto se realiza un muestreo aleatorio de los rayos de luz que alcanzan este punto. Cuando se realiza de esta forma se le llama raycasting con Monte Carlo. Como la luz se calcula no desde la fuente si no desde el punto, a esta alternativa de método se le llama backtracing.
En el siguiente método se expone el caso para calcular la iluminación de un punto en un plano 2D. Se compone de siete pasos que se pueden aplicar de forma recursiva cuando se quiere tener más detalle en términos de la oclusión entre los objetos que componen la escena e influyen radiantemente sobre el punto.</p><marker><img style="float: left;" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-globalillum6.png?" width="200" height="670">

</marker><ul><li><p>Paso 1: Seleccionar una ubicación aleatoria en el semidisco unitario. Esto se hace simplemente generando un número aleatorio entre 0 y pi. En el diagrama el semicirculo amarillo representa un vista hacia el horizonte para nosotros, en otras palabras, esto es una vista superior.</p></li><li><p>Paso 2: Notar que esta ubicación no está orientada a lo largo de la normal del punto que se quiere calcular. Para corregir esto se construye la matriz M a partir de las coordenadas del vector normal. Cuando se opera la ubicación escogida con esta matriz obtendremos un vector que está a lo largo del vector normal al punto que se desea calcular.</p></li><li><p>Paso 3: Con el vector normalizado, ahora se procede a generar un rayo. Este rayo puede verse como un factor escalar del vector normalizado, y con él se desea saber si golpea algún elemento de la escena.</p></li><li><p>Paso 4: El valor que se obtiene en la intersección se multiplicará por el valor de la normalización y esta será nuestra muestra de luz (color) para ese rayo.</p></li><li><p>Paso 5: Se acumula la contribución de luz calculada para cada muestra.</p></li><li><p>Paso 6: El acumulado obtenido en el paso anterior se divide entre la cantidad de muestras. Tal como se ve en la siguiente ecuación.</p></li></ul><p><span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>≈</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><mstyle scriptlevel="0" displaystyle="false"><msubsup><mo>∑</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mtext>&nbsp;</mtext><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>R</mi><mi>a</mi><mi>y</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mi>D</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>n</mi><mi>A</mi><mi>b</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>P</mi><mo stretchy="false">)</mo></mstyle></mrow><annotation encoding="application/x-tex">Gatherlight \thickapprox\frac 1 N\textstyle\sum_{n=0}^N\ castRay(P,randomDirectonAboveP)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326231em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace">&nbsp;</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">A</span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mclose">)</span></span></span></span></span></p><ul><li>Paso 7: Luego al acumulado promediado del paso 6 se le adiciona el valor obtenido por iluminación directa visto en la sección anterior y se multiplica por el albedo del objeto.</li></ul><p>Como se mencionó anteriormente este proceso se puede aplicar recursivamente para capturar mejor los detalles de la iluminación de la escena, pero es bastante costoso porque este método claramente escala exponencialmente (por cada muestra se obtienen otras n muestras). El siguiente diagrama muestra esta idea:</p><marker><p align="center">
  <img width="670" height="231" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-globalillum5.png?">
</p>

</marker><p>Notar también que este costo se puede contrarrestar pues para cada nivel de profundidad que se realiza este método la contribución de cada rayo a la iluminación del punto es cada vez menor, como consecuencia de la ley del coseno que aparece en el paso 4.
La técnica que se ha mostrado ilumina superficies difusas, como consecuencia de la aleatoriedad del método de Monte Carlo. Para representar otro tipo de superficies como sólidos que encierran líquidos o vidrio se deben tener en cuenta las consideraciones que se encuentran en la siguiente sección.</p><h2 id="el-uso-del-método-de-muestreo-difuso-indirecto-para-calcular-la-indirecta-especular-es-ineficiente" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>El uso del método de muestreo difuso indirecto para calcular la indirecta especular es ineficiente</h2><p>Hay 2 tipos de material: especular y difuso. Recuerde que una reflexión difusa es independiente de la vista. Una superficie difusa siempre tendrá el mismo brillo independientemente del ángulo que se mire. Las superficies especulares son diferentes: dependen de la vista. solo puede ver el reflejo de un objeto si el ángulo de visión está aproximadamente alineado con el reflejo del espejo a lo largo del cual se refleja la luz de este objeto. Esto esencialmente significa que los rayos de luz reflejados por una superficie brillante se reflejan dentro de un cono de direcciones orientadas alrededor de la dirección de reflexión.</p><marker><img style="float: left;" src="https://www.scratchapixel.com/images/upload/shading-intro2/shad2-indirectspec2.png?" width="300" height="332">

</marker><p>Para una superficie difusa, una luz siempre contribuye a la iluminación de P independientemente de su posición (siempre que la luz esté por encima de la superficie). Sin embargo, para una superficie especular, una luz solo puede ser visible si la dirección de la vista V está alineado de alguna manera aproximadamente con la dirección del espejo 
R de la dirección de la luz incidente. Qué tan cerca V y R tienen que estar, depende de la rugosidad de la superficie. Si la superficie es muy rugosa, es posible que refleje algo de luz a lo largo de la dirección de la vista, incluso si V no está estrechamente alineado con la dirección del espejo R. Aunque tan pronto como V esté totalmente fuera del cono de direcciones en las que la superficie refleja los rayos de luz, no debería haber luz reflejada.</p><p>Podemos usar esta observación para calcular el brillo del reflejo de un objeto por una superficie lustrosa. Si conocemos la dirección de la vista V, entonces solo los rayos de luz con ciertas direcciones de incidencia se reflejarán hacia los ojos a lo largo de V.
Imaginemos ahora el cono de direcciones en el que los rayos de luz se reflejan pero centrados alrededor VR. ¿qué sucede?, esto nos dice que cualquier rayo de luz cuya dirección de incidencia esté contenida dentro de ese cono de dirección se refleja de alguna manera a lo largo de V o al menos alguna cantidad mayor que 0.</p><p>Solo los rayos de luz contenidos dentro del cono de dirección centrado alrededor de VR contribuyen de alguna manera a la cantidad de luz que se refleja a lo largo de V. Por lo tanto, solo deberíamos estar interesados ​​en las direcciones contenidas dentro de ese cono. El problema con la técnica empleada hasta ahora, que consiste en muestrear todo el hemisferio, es que muchas de las direcciones creadas no están contenidas dentro de ese cono de dirección.</p><h2 id="cáusticas-la-pesadilla-del-rastreo-hacia-atrás" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Cáusticas: la pesadilla del rastreo hacia atrás</h2><p>Las cáusticas son el resultado de que los rayos de luz se enfoquen en puntos específicos o regiones del espacio de una superficie especular o como resultado de la refracción (los rayos de luz que pasan a través de un vaso de agua o vino se enfocan en un punto en el del vaso).</p><marker><img style="float: left;" src="https://www.scratchapixel.com/images/upload/shading-intro2/caustics.jpg?" width="350" height="300">

</marker><marker><p align="left">
  <img width="350" height="300" src="https://www.scratchapixel.com/images/upload/rendering-3d-scene-overview/caustics2.png?">
</p>

</marker><p>Las cáusticas son diferentes a los reflejos especulares indirectos, en los reflejos indirectos tenemos algún conocimiento previo de las direcciones en las que debemos proyectar los rayos. Estos deberían estar contenidos con el cono de direcciones del lóbulo especular. Aunque en el caso de las cáusticas, no sabemos en qué parte de la escena se crean estas. No sabemos en qué partes de la escena se concentran y se redirige los rayos de luz hacia P. Por supuesto, podemos aumentar el número de muestras N, pero es posible que deba aumentarlo a un número muy grande para reducir la varianza significativamente, y esto tiene el precio de aumentar considerablemente el tiempo de renderizado. Claramente, esta no es una buena solución. Una buena solución es aquella en la que disminuimos la varianza significativamente mientras mantenemos bajos los tiempos de renderizado.</p><h2 id="conclusiones" class="heading-0-0-1"><span class="anchor-0-0-2" data-ignore-text=""><span class="icon-font" data-ignore-text="" style="vertical-align: sub">link</span></span>Conclusiones</h2><ul><li>El método estadístico de montecarlo usado en el cálculo de la iluminación es la mejor opción  para el problema de la iluminación indirecta con el rastreo hacia atrás.</li><li>La representación de superficies especulares debe hacerse de tal manera que los ángulos de los rayos están contenidos en el cono de visión.</li><li>El método de iluminación en un punto puede ser ineficiente en términos</li><li>Debido a las propiedades de las superficies especulares, al tratar de hacer un mapeo del hemisferio se genera mucho ruido debido a que no todos los puntos son significativos para el cálculo de la iluminación.</li><li>El proceso de simular el trazado de rayos para iluminación indirecta es complejo y costoso computacionalmente por esto mismo no ha sido muy usado hasta que se ha tenido mayor poder de cálculo y mejores algoritmos que lo optimicen </li></ul><div class="contentnav-0-0-16" data-no-search=""><a href="#iluminación-global" class="h1" data-content-highlight="iluminación-global">Iluminación global</a><a href="#¿qué-es-la-iluminación-global-de-todos-modos" class="h2" data-content-highlight="¿qué-es-la-iluminación-global-de-todos-modos">¿Qué es la iluminación global de todos modos?</a><a href="#¿cómo-simulamos-la-iluminación-indirecta-con-el-rastreo-hacia-atrás" class="h2" data-content-highlight="¿cómo-simulamos-la-iluminación-indirecta-con-el-rastreo-hacia-atrás">¿Cómo simulamos la iluminación indirecta con el rastreo hacia atrás?</a><a href="#monte-carlo" class="h3" data-content-highlight="monte-carlo">Monte Carlo</a><a href="#¿qué-entendemos-por-muestreo" class="h2" data-content-highlight="¿qué-entendemos-por-muestreo">¿Qué entendemos por muestreo?</a><a href="#el-uso-del-método-de-muestreo-difuso-indirecto-para-calcular-la-indirecta-especular-es-ineficiente" class="h2" data-content-highlight="el-uso-del-método-de-muestreo-difuso-indirecto-para-calcular-la-indirecta-especular-es-ineficiente">El uso del método de muestreo difuso indirecto para calcular la indirecta especular es ineficiente</a><a href="#cáusticas-la-pesadilla-del-rastreo-hacia-atrás" class="h2" data-content-highlight="cáusticas-la-pesadilla-del-rastreo-hacia-atrás">Cáusticas: la pesadilla del rastreo hacia atrás</a><a href="#conclusiones" class="h2" data-content-highlight="conclusiones">Conclusiones</a></div></div><div id="-codedoc-toc" class="toc-0-0-13"><div class="content-0-0-14"><p><a href="/vc/">Home</a></p><div class="collapse-0-0-9 "><script id="eFCOWtgVwN">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("eFCOWtgVwN", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Workshops</span><span class="icon-font closed">chevron_right</span></div><div class="content"><div class="collapse-0-0-9 "><script id="bVPUWIuGga">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("bVPUWIuGga", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Workshop 1</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/workshops/workshop1/imgLumaKernel">Image Luma &amp; Kernel</a>
<a href="/vc/docs/workshops/workshop1/vidLumaKernel">Video Luma &amp; Kernel</a>
<a href="/vc/docs/workshops/workshop1/photoMosaic">Photographic mosaic</a>
<a href="/vc/docs/workshops/workshop1/asciiArt">Ascii art</a></p></div></div><div class="collapse-0-0-9 "><script id="WIuorwyNPw">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("WIuorwyNPw", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Workshop 2</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/workshops/workshop2/lumi">Global Illumination</a>
<a href="/vc/docs/workshops/workshop2/hardwareGray">Hardware Weighted Gray</a>
<a href="/vc/docs/workshops/workshop2/asciiart">Ascii Art (Shaders)</a>
<a href="/vc/docs/workshops/workshop2/photomosaic">Photomosaic (Shaders)</a></p></div></div></div></div><div class="collapse-0-0-9 "><script id="fqmJYSKdrk">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("fqmJYSKdrk", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">P5 Code Snippets</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/snippets/component">P5 Component</a>
<a href="/vc/docs/snippets/basic">Basics</a>
<a href="/vc/docs/snippets/video-dom">Video on dom</a>
<a href="/vc/docs/snippets/video-canvas">Video on canvas</a>
<a href="/vc/docs/snippets/3d">3D</a>
<a href="/vc/docs/snippets/lib">Libs</a>
<a href="/vc/docs/snippets/sound">Sound</a></p></div></div><div class="collapse-0-0-9 "><script id="FQrnzJFSkB">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("FQrnzJFSkB", "lqlJyab6eRMclBlk8Ftb8g==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script><div class="label" onclick="this.parentElement.classList.toggle('open')"><span class="text">Team</span><span class="icon-font closed">chevron_right</span></div><div class="content"><p><a href="/vc/docs/members/Sebastian-Castaneda">Sebastian Castañeda</a>
<a href="/vc/docs/members/Camilo-Florez">Camilo Florez</a>
<a href="/vc/docs/members/Marcel-Martinez">Marcel Martinez</a>
<a href="/vc/docs/members/Luis-Sandoval">Luis Sandoval</a></p></div></div></div><div class="search-0-0-15"><script id="WcqRSqBXUU">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("WcqRSqBXUU", "MChpnTvN8BpuKyiMGzmSYw==", {"repo":"vc","user":"CompuVisual2021","root":"docs/md","pick":"\\.md$","drop":"(^_)|(\\/_)"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><div class="footer-0-0-12"><div class="left"><script id="gIsGdNxjnl">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("gIsGdNxjnl", "X5W7He+ge/Kg3B6xB+T5gg==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div><div class="main"><div class="inside"><a href="https://github.com/CompuVisual2021/vc/" target="_blank">GitHub</a></div></div><div class="right"><script id="xppXOypUxn">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("xppXOypUxn", "3ehN2Qj7wHC4donAKEDe0Q==", {});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></div></div><script id="PjJiqwDxtH">(function(){function load(){if (window.__sdh_transport){window.__sdh_transport("PjJiqwDxtH", "bIAidu6MCPVPBcGGWLCR6Q==", {"namespace":"/vc"});} }; if (document.readyState == 'complete') load(); else window.addEventListener('load', load); })()</script></body></html>